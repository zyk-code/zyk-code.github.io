import{_ as s,c as a,o as i,a5 as n}from"./chunks/framework.D_DqNR2H.js";const b=JSON.parse('{"title":"STL","description":"","frontmatter":{},"headers":[],"relativePath":"note/c++/STL.md","filePath":"note/c++/STL.md","lastUpdated":1729521748000}'),e={name:"note/c++/STL.md"},t=n(`<h1 id="stl" tabindex="-1">STL <a class="header-anchor" href="#stl" aria-label="Permalink to &quot;STL&quot;">​</a></h1><p>STL：容器、算法、迭代器、适配器、内存分配器（空间配置器）和函数对象（仿函数）。迭代器将容器和算法进行无缝链接。函数模板和类模板实现，标准模板库。容器和算法的桥梁时迭代器。</p><h2 id="容器contine" tabindex="-1">容器contine <a class="header-anchor" href="#容器contine" aria-label="Permalink to &quot;容器contine&quot;">​</a></h2><p>序列式和关联式容器。</p><h3 id="string" tabindex="-1">string <a class="header-anchor" href="#string" aria-label="Permalink to &quot;string&quot;">​</a></h3><p><code>string</code>与 <code>char*</code>的区别：前者是一个类，在类的内部维护了一个 <code>char*</code>。<code>string</code>实现了对 <code>char*</code>的内存管理，避免了内存越界（取值和赋值）。提供了很多的成员方法。</p><h3 id="vector" tabindex="-1">vector <a class="header-anchor" href="#vector" aria-label="Permalink to &quot;vector&quot;">​</a></h3><p><code>begin</code>：是位于vector的第一元素上的迭代器，<code>end</code>: 为最后一个元素的下一位上。</p><h3 id="queue" tabindex="-1">queue <a class="header-anchor" href="#queue" aria-label="Permalink to &quot;queue&quot;">​</a></h3><h3 id="map与set" tabindex="-1">map与set <a class="header-anchor" href="#map与set" aria-label="Permalink to &quot;map与set&quot;">​</a></h3><p><code>map</code>和<code>set</code>都是关联式容器，区别在于：map是键值对，set是键值，map的键值对可以重复，set的键值不能重复。</p><p><code>map</code>和<code>set</code>的底层实现是红黑树。<code>unordered_map</code>和<code>unordered_set</code>底层实现是哈希表。</p><p>find 和 count 都是查找，但是count返回的是个数，find会返回一个迭代器（当不存在key时，会返回map.end()）。在set中没有find方法。</p><h2 id="适配器" tabindex="-1">适配器 <a class="header-anchor" href="#适配器" aria-label="Permalink to &quot;适配器&quot;">​</a></h2><h2 id="迭代器" tabindex="-1">迭代器 <a class="header-anchor" href="#迭代器" aria-label="Permalink to &quot;迭代器&quot;">​</a></h2><h2 id="函数对象" tabindex="-1">函数对象 <a class="header-anchor" href="#函数对象" aria-label="Permalink to &quot;函数对象&quot;">​</a></h2><ol><li>函数对象和普通函数类似，拥有参数和返回值。</li><li>函数对象内部可以拥有自己的状态表示。</li><li>函数对象可以作为参数传递（回调）。普通函数是要通过指针。</li></ol><h3 id="谓词" tabindex="-1">谓词 <a class="header-anchor" href="#谓词" aria-label="Permalink to &quot;谓词&quot;">​</a></h3><p>返回<strong>布尔类型</strong>的仿函数（函数对象）称为谓词。该仿函数<strong>接收一个参数即一元谓词，接收两个参数即二元谓词。</strong></p><h4 id="一元谓词" tabindex="-1">一元谓词 <a class="header-anchor" href="#一元谓词" aria-label="Permalink to &quot;一元谓词&quot;">​</a></h4><div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> One</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> thread </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    bool</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> operator</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">-&gt;thread </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> val;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h4 id="二元谓词" tabindex="-1">二元谓词 <a class="header-anchor" href="#二元谓词" aria-label="Permalink to &quot;二元谓词&quot;">​</a></h4><div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Two</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    bool</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> operator</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> num_1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> num_2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> num_1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> num_2;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="内建的函数对象" tabindex="-1">内建的函数对象 <a class="header-anchor" href="#内建的函数对象" aria-label="Permalink to &quot;内建的函数对象&quot;">​</a></h3><p><code>#include&lt;functional&gt;</code></p><p>算术</p><p>关系</p><p>逻辑</p><h2 id="算法" tabindex="-1">算法 <a class="header-anchor" href="#算法" aria-label="Permalink to &quot;算法&quot;">​</a></h2><p><code>#include&lt;algorithm&gt;</code></p>`,30),l=[t];function h(p,r,d,o,k,c){return i(),a("div",null,l)}const g=s(e,[["render",h]]);export{b as __pageData,g as default};
