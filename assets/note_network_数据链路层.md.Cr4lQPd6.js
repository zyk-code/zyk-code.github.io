import{_ as a,c as t,o,a5 as e,aa as r}from"./chunks/framework.CoTJ3bXK.js";const u=JSON.parse('{"title":"数据链路层","description":"","frontmatter":{},"headers":[],"relativePath":"note/network/数据链路层.md","filePath":"note/network/数据链路层.md","lastUpdated":1713021612000}'),n={name:"note/network/数据链路层.md"},s=e('<h1 id="数据链路层" tabindex="-1">数据链路层 <a class="header-anchor" href="#数据链路层" aria-label="Permalink to &quot;数据链路层&quot;">​</a></h1><h3 id="概述" tabindex="-1">概述 <a class="header-anchor" href="#概述" aria-label="Permalink to &quot;概述&quot;">​</a></h3><p><strong>链路</strong>是结点间的一段物理线路。</p><p><strong>数据链路</strong>是在链路的基础上增加的必要的硬件（网络适配器）和软件（协议）。</p><p>在该层传输协议的<strong>数据单元</strong>是帧。</p><p><img src="'+r+'" alt="链路" loading="lazy"></p><h3 id="数据单元的封装" tabindex="-1">数据单元的封装 <a class="header-anchor" href="#数据单元的封装" aria-label="Permalink to &quot;数据单元的封装&quot;">​</a></h3><p><strong>封装成帧</strong>是在一段数据的前后分别添加首部和尾部，构成一个帧。首部和尾部是帧的一个重要的分界。</p><p><strong>帧</strong>：帧首部（SOH） || 数据部 || 协议首部 || 协议尾部 || 帧尾部(EOT)</p><h3 id="透明传输" tabindex="-1">透明传输 <a class="header-anchor" href="#透明传输" aria-label="Permalink to &quot;透明传输&quot;">​</a></h3><p><strong>概念</strong>：当数据部的某个字节的<strong>二进制代码和<code>SOH</code>或<code>EOT</code>一样</strong>，数据链路层就会<strong>错误的找到当前帧的边界</strong>。</p><p><strong>解决方式</strong>：在发送端的数链路层在数据部中出现控制字符<code>SOH</code>或<code>EOT</code>时，<strong>在帧的前部和尾部的字符插入以个转义字符<code>ESC</code></strong>。</p><h3 id="差错检测" tabindex="-1">差错检测 <a class="header-anchor" href="#差错检测" aria-label="Permalink to &quot;差错检测&quot;">​</a></h3><h4 id="方法" tabindex="-1">方法 <a class="header-anchor" href="#方法" aria-label="Permalink to &quot;方法&quot;">​</a></h4><p><strong>奇偶校验</strong></p><p><strong>CRC</strong></p>',16),d=[s];function c(i,l,h,_,p,g){return o(),t("div",null,d)}const f=a(n,[["render",c]]);export{u as __pageData,f as default};
