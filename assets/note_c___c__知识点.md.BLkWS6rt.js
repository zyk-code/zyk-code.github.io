import{_ as s,c as i,o as a,a5 as n,a6 as p}from"./chunks/framework.D5vfm64Q.js";const y=JSON.parse('{"title":"c++知识点","description":"","frontmatter":{},"headers":[],"relativePath":"note/c++/c++知识点.md","filePath":"note/c++/c++知识点.md","lastUpdated":1714997510000}'),e={name:"note/c++/c++知识点.md"},t=n(`<h1 id="c-知识点" tabindex="-1">c++知识点 <a class="header-anchor" href="#c-知识点" aria-label="Permalink to &quot;c++知识点&quot;">​</a></h1><h2 id="基本类型" tabindex="-1">基本类型 <a class="header-anchor" href="#基本类型" aria-label="Permalink to &quot;基本类型&quot;">​</a></h2><p><strong>整型</strong>：char -&gt; int -&gt; long -&gt; long long。占用的字节大小由编译器决定，一般为1,4,8个字节。该顺序是运算时隐式转换的等级。</p><p><strong>浮点型</strong>：float -&gt; double-&gt; long double。占用的字节大小由编译器决定，一般为4,8个字节。该顺序是运算时隐式转换的等级。</p><h3 id="bool类型" tabindex="-1">bool类型 <a class="header-anchor" href="#bool类型" aria-label="Permalink to &quot;bool类型&quot;">​</a></h3><p>布尔类型不属于c++的基本类型，它是由编译器定义的，其值为1或0。</p><h3 id="指针类型" tabindex="-1">指针类型 <a class="header-anchor" href="#指针类型" aria-label="Permalink to &quot;指针类型&quot;">​</a></h3><p><code>*</code>这种类型占用的内存大小是4个字节，与指针修饰的变量类型无关。</p><h3 id="void类型" tabindex="-1">void类型 <a class="header-anchor" href="#void类型" aria-label="Permalink to &quot;void类型&quot;">​</a></h3><p><code>void* </code> void类型指针表示声明任意类型的指针。该指针在赋值时需要转换类型。该指针只关注指针的地址，因此在查看变量地址时，可以使用。</p><h2 id="指针" tabindex="-1">指针 <a class="header-anchor" href="#指针" aria-label="Permalink to &quot;指针&quot;">​</a></h2><div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int**</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pp </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>指针变量</strong>是存放指针的地址的变量，如<code>p</code>和<code>pp</code>。 <strong>二级指针</strong>是指向指针的指针，如<code>int** pp = &amp;p;</code>。 <code>*p</code> 是指针p的解引用，可以进行层级套用，如<code>**pp</code>。解一次和两次引用是不同的。 <strong>+1</strong>是将指针地址加上当前指向数据类型的内存字节大小。 <strong>大小</strong>：在32位系统是4个字节，64位系统是8个字节。</p><h3 id="野指针和空指针" tabindex="-1">野指针和空指针 <a class="header-anchor" href="#野指针和空指针" aria-label="Permalink to &quot;野指针和空指针&quot;">​</a></h3><p><strong>野指针</strong>是指针初始化时没有提供初始值<code>int* p;</code>、<code>delet</code>释放了内存空间还被使用和指针指向了超出作用域的变量时。前面两种情况，容易导致程序崩溃，在不同平台编译器处理结果不同。最后一种程序不会崩溃，但这样更加危险。可以在定义指针时，初始化为空指针。 <strong>指针指向了超出作用域的变量(数组越界也是这种情况吧)</strong></p><div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> func</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // a的值是10 地址是0x11111111</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// p是0x11111111 *p即解引用的值是随机的。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> func</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><strong>空指针</strong>是。在c++11以后使用<code>nullprt</code>表示空指针的地址。在c/c++11前中是<code>NULL</code>/<code>0</code>。解引用空指针会导致程序崩溃，因此在代码中加入<code>判空</code>可以提升程序的健壮性。可以被<code>delet</code>释放内存。</p><h3 id="函数指针" tabindex="-1">函数指针 <a class="header-anchor" href="#函数指针" aria-label="Permalink to &quot;函数指针&quot;">​</a></h3><p>函数指针是指向函数代码的地址（函数代码存放在代码段）。函数指针定义时和函数返回值类型和形参类型相关。常用用于回调函数的调用。</p><div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fun</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> num</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> num_1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    cout</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> num </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> num_1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> endl;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (*funp)(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">funp</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fun;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">funp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // c++调用的方式;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">funp)(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // c调用的方式;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="const修饰指针" tabindex="-1">const修饰指针 <a class="header-anchor" href="#const修饰指针" aria-label="Permalink to &quot;const修饰指针&quot;">​</a></h2><p>const修饰变时，会将变量作为常量。当const修饰指针时，大有不同，有一下三种方式。</p><p><strong>常量指针</strong>：<code>const int* var = &amp;a;</code> 定义的是常量指针。常量指针不可通过通过解引用进行值的修改如<code>*var = 10</code>，但可以通过<code>a = 10</code>完成修改。常量指针可以更换指向的变量，如<code>var = &amp;b</code>，但同样不使用解引用。<strong>在函数传参时的形参使用，表明在函数内部不改变传入的值，提高代码可读性</strong></p><p><strong>指针常量</strong>：<code>int* const var = &amp;a;</code> 定义的是指针常量。指针常量可以通过<code>*var = 10</code>进行修改，与引用的作用一样。</p><p><strong>常指针常量</strong>：<code>const int* const var = &amp;a;</code> 定义的是常指针常量。常指针常量既不可通过解引用进行值的修改，也不可更换指向的变量。</p><h2 id="引用" tabindex="-1">引用 <a class="header-anchor" href="#引用" aria-label="Permalink to &quot;引用&quot;">​</a></h2><p>c++新增类型，<code>int a = 1; int&amp; b = a;</code>定了引用b。引用的数据类型必须相同，不可强转。</p><p>整个过程a与a的引用地址始终相同.</p><div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ra </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// a = 1 / ra =1 </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// b </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ra </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// a = 2, ra =2</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>引用是伪装的指针常量.传引用会将形参和实参一起进行改变.<code>int* pt; int*&amp; p = pt;</code> 指针的引用,可以替换二级指针.数组不存在引用.</p><p><code>const</code>修饰时,会创建临时变量让引用指向临时变量,在函数直接时,形参存在引用时会出现该情况,<code>const</code>修改指针时不会.</p><p><strong>返回引用</strong>可以减少内存的拷贝,常用于大的数据类型返回值(一般为引用传递的形参),<em>注意</em>返回局部变量视为操作野指针.</p><h2 id="数组" tabindex="-1">数组 <a class="header-anchor" href="#数组" aria-label="Permalink to &quot;数组&quot;">​</a></h2><p><strong>初始化</strong>：<code>int arry[3];</code> []内部数组长度，必须为常数，在linux平台下是可以是使用<code>int a =10; int b[a];</code>。数组下标以0开始。<code>int a[2] = {1, 2}</code>。<code>int a[2] = {0} === int a[2] = {}</code> 都是 {0, 0}。<code>int a[2] = {1}</code>，是{1, 0}。</p><p><strong>遍历方式</strong>：for循环，foreach<code>for(auto item: arry){}</code></p><p><strong>拷贝方式</strong>：不可直接通过<code>=</code>进行拷贝，通过<code>mempy(a, b)</code> b==&gt;a</p><p><strong>越界</strong>：在不同的平台的表现不同，本质是野指针。</p><p><strong>作为参数传递</strong>：形参<code>void func(int arr[], int len)</code>或者<code>void func(int* arr, int len)</code>，在函数内部使用<code>sizeof</code>是用第一种方式，数组指针。</p><p><strong>二维数组</strong>；在内存中二维数组的空间也是连续的。因此可用过<code>int a[2][3] = {1, 2, 3, 4, 5, 6}</code>进行初始化分配。</p><p><strong>行指针(数组指针)</strong>；<code>int (*a)[3]</code> 指向在二维数组中行为3的数组。<code>void fun(int p[][3], int len)</code>/<code>void fun(int (*p)[3], int len)</code>将二维数组作为参数传递的方式。</p><div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">][</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(p</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>动态数组</strong>：在堆上分配内存，<code>type* p = new tpye[];</code> 返回也是第一元素的地址。注意需要通过<code>delet[] p;</code>释放内存，不可使用~<code>sizeof</code>~获取数组长度。</p><h3 id="数组指针" tabindex="-1">数组指针 <a class="header-anchor" href="#数组指针" aria-label="Permalink to &quot;数组指针&quot;">​</a></h3><p>数组指针是一个指向数组的指针。数组在C++中是连续存储的，所以数组名本身就是一个指针。当你声明一个数组时，数组名就是这个数组首元素的地址，但数组名并不只代表着地址在sizeof时返回的整个数组的长度。 当指向数组为二维数组时，注意指针的嵌套关系</p><div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// a的值是&amp;a[0]即第一个值的地址，。因此在使用指针操作数组时，不需&amp;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a; </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //等价于指向a[0]的指针</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //等价于指向a[1]的指针</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(p</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //取得a[1]的数组</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //是a[0] = a[0]+1</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="排序" tabindex="-1">排序 <a class="header-anchor" href="#排序" aria-label="Permalink to &quot;排序&quot;">​</a></h3><p><code>void qsort(void* base, size_t len, size_t type_size, int(*compare)(const void* p1, const void* p2))</code>形参的依次作用是，数组第一个值，数组长度，数组元素类型大小，回调函数（决定是顺序还逆序)</p><div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> compare</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> p1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> p2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //当值大于0是交换前后，当小于0是后前互相，等于0时不确定。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)p1)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)p2)</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 顺序</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // return (*(int*)p2)-(*(int*)p1) // 逆序</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="c风格的字符串" tabindex="-1">c风格的字符串 <a class="header-anchor" href="#c风格的字符串" aria-label="Permalink to &quot;c风格的字符串&quot;">​</a></h2><p>c++的<code>string</code>类封装了c风格的字符串。<code>string</code>会自动拓展内存空间。</p><p><code>char s = &quot;abc&quot;</code>和\`\`char s[] = &quot;abc&quot;<code> 前者为字符，后者为字符串，其**末尾是存在</code>\\0\`**。因为c语言中字符串以空字符结尾，所以在申请内存时需要多预留以为的内存空间空间。</p><p><strong>定义与初始化</strong>：<code>char s[21];</code> 定义了存放20个字符的字符串。初始化<code>char s[21] = {0}</code>，定义字符串需要初始化否则会存在危险，存放垃圾值。</p><p><strong>清空字符串</strong>：1、使用<code>menset(name, 0, sizeof(name))</code>将整个字符串清空为<code>\\0</code>。2、<code>name[0] = 0;</code>将字符串的第一元素设置为<code>\\0</code>，但后面的元素会随机化（成为垃圾值）。</p><p><strong>拷贝</strong>：<code>strcopy(a, b)</code>和<code>strncopy(a, b, n)</code>，后者拷贝b的n个字符，不会追加空字符。</p><p><strong>拼接</strong>；c++可以通过<code>+</code>或<code>strcat</code> <code>strncat</code></p><h2 id="内存管理" tabindex="-1">内存管理 <a class="header-anchor" href="#内存管理" aria-label="Permalink to &quot;内存管理&quot;">​</a></h2><h3 id="内存空间" tabindex="-1">内存空间 <a class="header-anchor" href="#内存空间" aria-label="Permalink to &quot;内存空间&quot;">​</a></h3><p>内存空间包含：内核空间、栈、堆、数据段、代码段。地址从高到低。如下图：</p><p><img src="`+p+`" alt="men" loading="lazy"></p><p><strong>内核空间</strong>是操作系统内核所占用的空间，这部分空间是受保护的，不能被用户直接访问。</p><p><strong>栈</strong>是函数调用时使用的空间，每个函数调用都会创建一个栈帧，用于存储函数的<strong>局部变量</strong>、<strong>函数参数</strong>和<strong>函数返回值</strong>。栈空间是自动分配和释放的，栈空间的大小是固定的，可以通过设置栈的大小来控制函数调用的深度。</p><p><strong>堆</strong>是用于动态分配内存的空间，程序可以通过调用malloc、new等函数来在堆上分配内存。堆空间的大小是不固定的，可以通过设置堆的大小来控制内存的使用。</p><p><strong>数据段</strong>是用于存储程序中定义的<strong>静态变量</strong>、<strong>全局变量</strong>等。数据段的空间是固定的，程序运行时会分配相应的空间。</p><p><strong>代码段</strong>是用于存储程序的代码。代码段的空间是固定的，程序运行时会分配相应的空间。</p><h3 id="栈与堆的区别" tabindex="-1">栈与堆的区别 <a class="header-anchor" href="#栈与堆的区别" aria-label="Permalink to &quot;栈与堆的区别&quot;">​</a></h3><p>1、管理方式不同，栈会自动释放空间，而堆需要手动释放空间。</p><p>2、空间大小不同，堆的受限于物理内存空间，栈会更小一点。</p><p>3、分配方式不同，栈是静态分配，而堆是动态分配。</p><p>4、分配效率不同，栈由操作系统支持，效率会更高。</p><p>5、堆由于频繁分配和释放，会导致内存空间不连续，容易产生内存碎片，会导致性能下降。栈是按照进出栈的顺序存放的，因此不会产生碎片。</p><p>6、栈向下增长，堆向上增长。</p><h3 id="堆区内存使用" tabindex="-1">堆区内存使用 <a class="header-anchor" href="#堆区内存使用" aria-label="Permalink to &quot;堆区内存使用&quot;">​</a></h3><p>1、申请内存。<code>int* p = new int(5);</code> c++通过new关键字动态分配内存，在面向对象编程时常用。在c中可以通过<code>malloc</code>函数动态分配内存。<code>int* p = new (std::nothorw)int[5];</code>这样在申请的堆内存不足会返回空指针<code>nullpt</code>。</p><p>2、使用内存。<code>*p = 8;</code> 内存的操作和使用只能通过指针实行。</p><p>3、释放内存。c++通过<code>delet p;</code>。c通过free关键字释放内存。如果不释放会导致内存泄漏。不可重复释放同一内存，视为操作野指针。</p><p><strong>内存泄漏</strong>是指程序中不再使用的内存没有及时释放，导致内存占用越来越多，最终导致内存溢出。</p><p><strong>内存溢出</strong>是指程序中使用的内存超过了系统分配的内存，导致程序无法继续运行。</p><p><em>注意</em>：动态内存不与变量绑定。因此，动态内存的生命周期和整个程序相同，即使操作该内存的指针在某作用域失效申请的动态内存依然存在。当程序结束时，系统将自动回未释放的内存。</p><h2 id="结构体" tabindex="-1">结构体 <a class="header-anchor" href="#结构体" aria-label="Permalink to &quot;结构体&quot;">​</a></h2><div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c};</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 正式命名</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{} </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">n</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 别名</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // c必须struct，可以使用第二种方式定义</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">name b;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // c++不需要</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>结构体名是标识符。C++中不提倡使用类作为成员和函数作为成员。</p><p>初始化值的方式<code>name a = {0}</code>或<code>name a{0}</code> <code>name a = {1, 2, 3}</code>，初始化可以在定义时在结尾追加。</p><p><strong>内存占用大小</strong>；结构体是会内存对齐，<code>pragam park(字节数)</code>修改对齐的规则，取决于编译器。</p><h3 id="结构体指针" tabindex="-1">结构体指针 <a class="header-anchor" href="#结构体指针" aria-label="Permalink to &quot;结构体指针&quot;">​</a></h3><div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">name a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 访问成员方式</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p).a;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p-&gt;a;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><em>结构体变量名和数组不同，并没有解析为地址</em></p><p><strong>可以通过new关键字进行动态分配内存</strong></p><h3 id="结构体中的指针" tabindex="-1">结构体中的指针 <a class="header-anchor" href="#结构体中的指针" aria-label="Permalink to &quot;结构体中的指针&quot;">​</a></h3><p>当结构体中成员变量含有指针时，<code>sizeof</code>和<code>menset</code>函数的使用，后者可能会导致内存泄漏<code>menset</code>一般用于清空会将指针的地址变为空指针。需要单独对带指针的成员进行清空。<code>string</code>结构体中就存在一个这样的成员，因此当结构体中存在<code>string</code>类型时需要注意。</p><h2 id="共同体" tabindex="-1">共同体 <a class="header-anchor" href="#共同体" aria-label="Permalink to &quot;共同体&quot;">​</a></h2><p>又称为联合体、共用体。<code>union</code>关键字。共同体占用内存大小是<strong>成员类型中内存占用最大</strong>的大小，存在内存对齐。所有成员使用同一块内存。共同体的值为最后一个进行赋值操作成员的值。linux支持匿名共同体。</p><h2 id="枚举" tabindex="-1">枚举 <a class="header-anchor" href="#枚举" aria-label="Permalink to &quot;枚举&quot;">​</a></h2><p>创建常量的一种方式</p><div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">enum</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> colors</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">red</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">bule</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">green</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">other</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 0001</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">colors a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> red;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 只能在以上四种选择一个</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="函数" tabindex="-1">函数 <a class="header-anchor" href="#函数" aria-label="Permalink to &quot;函数&quot;">​</a></h2>`,95),l=[t];function h(k,r,d,o,c,E){return a(),i("div",null,l)}const b=s(e,[["render",h]]);export{y as __pageData,b as default};
