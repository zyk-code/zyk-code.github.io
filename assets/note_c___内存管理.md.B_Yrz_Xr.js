import{_ as t,c as e,o,a5 as a,a6 as r}from"./chunks/framework.CAsUj2FB.js";const f=JSON.parse('{"title":"内存管理","description":"","frontmatter":{},"headers":[],"relativePath":"note/c++/内存管理.md","filePath":"note/c++/内存管理.md","lastUpdated":1713972979000}'),n={name:"note/c++/内存管理.md"},s=a('<h1 id="内存管理" tabindex="-1">内存管理 <a class="header-anchor" href="#内存管理" aria-label="Permalink to &quot;内存管理&quot;">​</a></h1><h3 id="内存空间" tabindex="-1">内存空间 <a class="header-anchor" href="#内存空间" aria-label="Permalink to &quot;内存空间&quot;">​</a></h3><p>内存空间包含：内核空间、栈、堆、数据段、代码段。地址从高到低。如下图：</p><p><img src="'+r+'" alt="men" loading="lazy"></p><p><strong>内核空间</strong>是操作系统内核所占用的空间，这部分空间是受保护的，不能被用户直接访问。</p><p><strong>栈</strong>是函数调用时使用的空间，每个函数调用都会创建一个栈帧，用于存储函数的<strong>局部变量</strong>、<strong>函数参数</strong>和<strong>函数返回值</strong>。栈空间是自动分配和释放的，栈空间的大小是固定的，可以通过设置栈的大小来控制函数调用的深度。</p><p><strong>堆</strong>是用于动态分配内存的空间，程序可以通过调用malloc、new等函数来在堆上分配内存。堆空间的大小是不固定的，可以通过设置堆的大小来控制内存的使用。</p><p><strong>数据段</strong>是用于存储程序中定义的<strong>静态变量</strong>、<strong>全局变量</strong>等。数据段的空间是固定的，程序运行时会分配相应的空间。</p><p><strong>代码段</strong>是用于存储程序的代码。代码段的空间是固定的，程序运行时会分配相应的空间。</p><h3 id="栈与堆的区别" tabindex="-1">栈与堆的区别 <a class="header-anchor" href="#栈与堆的区别" aria-label="Permalink to &quot;栈与堆的区别&quot;">​</a></h3><p>1、管理方式不同，栈会自动释放空间，而堆需要手动释放空间。</p><p>2、空间大小不同，堆的受限于物理内存空间，栈会更小一点。</p><p>3、分配方式不同，栈是静态分配，而堆是动态分配。</p><p>4、分配效率不同，栈由操作系统支持，效率会更高。</p><p>5、堆由于频繁分配和释放，会导致内存空间不连续，容易产生内存碎片，会导致性能下降。栈是按照进出栈的顺序存放的，因此不会产生碎片。</p><p>6、栈向下增长，堆向上增长。</p><h2 id="堆区内存使用" tabindex="-1">堆区内存使用 <a class="header-anchor" href="#堆区内存使用" aria-label="Permalink to &quot;堆区内存使用&quot;">​</a></h2><p>1、申请内存。<code>int* p = new int(5);</code> c++通过new关键字动态分配内存，在面向对象编程时常用。在c中可以通过<code>malloc</code>函数动态分配内存。</p><p>2、使用内存。<code>*p = 8;</code> 内存的操作和使用只能通过指针实行。</p><p>3、释放内存。c++通过<code>delet p;</code>。c通过free关键字释放内存。如果不释放会导致内存泄漏。</p><p><strong>内存泄漏</strong>是指程序中不再使用的内存没有及时释放，导致内存占用越来越多，最终导致内存溢出。</p><p><strong>内存溢出</strong>是指程序中使用的内存超过了系统分配的内存，导致程序无法继续运行。</p><p><em>注意</em>：动态内存不与变量绑定。因此，动态内存的生命周期和整个程序相同，即使操作该内存的指针在某作用域失效申请的动态内存依然存在。当程序结束时，系统将自动回未释放的内存。</p>',23),p=[s];function c(d,i,l,_,g,h){return o(),e("div",null,p)}const u=t(n,[["render",c]]);export{f as __pageData,u as default};
