# c++知识点

## 基本类型

**整型**：char -> int -> long -> long long。占用的字节大小由编译器决定，一般为1,4,8个字节。该顺序是运算时隐式转换的等级。

**浮点型**：float -> double-> long double。占用的字节大小由编译器决定，一般为4,8个字节。该顺序是运算时隐式转换的等级。

### bool类型

布尔类型不属于c++的基本类型，它是由编译器定义的，其值为1或0。

### 指针类型

`*`这种类型占用的内存大小是4个字节，与指针修饰的变量类型无关。

### void类型

`void* ` void类型指针表示声明任意类型的指针。该指针在赋值时需要转换类型。该指针只关注指针的地址，因此在查看变量地址时，可以使用。

## 指针

```cpp
int a = 10;
int* p = &a;
int** pp = &p; 
```

**指针变量**是存放指针的地址的变量，如`p`和`pp`。
**二级指针**是指向指针的指针，如`int** pp = &p;`。
`*p` 是指针p的解引用，可以进行层级套用，如`**pp`。解一次和两次引用是不同的。
**+1**是将指针地址加上当前指向数据类型的内存字节大小。
**大小**：在32位系统是4个字节，64位系统是8个字节。

### 野指针和空指针

**野指针**是指针初始化时没有提供初始值`int* p;`、`delet`释放了内存空间还被使用和指针指向了超出作用域的变量时。前面两种情况，容易导致程序崩溃，在不同平台编译器处理结果不同。最后一种程序不会崩溃，但这样更加危险。可以在定义指针时，初始化为空指针。
**指针指向了超出作用域的变量(数组越界也是这种情况吧)**
```cpp
int* func(){
    // a的值是10 地址是0x11111111
    int a = 10;
    return &a;
}
// p是0x11111111 *p即解引用的值是随机的。
int* p = func();
```

**空指针**是。在c++11以后使用`nullprt`表示空指针的地址。在c/c++11前中是`NULL`/`0`。解引用空指针会导致程序崩溃，因此在代码中加入`判空`可以提升程序的健壮性。可以被`delet`释放内存。

### 函数指针

函数指针是指向函数代码的地址（函数代码存放在代码段）。函数指针定义时和函数返回值类型和形参类型相关。常用用于回调函数的调用。
```cpp
void fun(int num, int num_1){
    cout<< num + num_1 << endl;
}
void (*funp)(int, int);
funp=fun;
funp(1,2); // c++调用的方式;
(*funp)(1,2)); // c调用的方式;
```

## const修饰指针

const修饰变时，会将变量作为常量。当const修饰指针时，大有不同，有一下三种方式。

**常量指针**：`const int* var = &a;` 定义的是常量指针。常量指针不可通过通过解引用进行值的修改如`*var = 10`，但可以通过`a = 10`完成修改。常量指针可以更换指向的变量，如`var = &b`，但同样不使用解引用。**在函数传参时的形参使用，表明在函数内部不改变传入的值，提高代码可读性**

**指针常量**：`int* const var = &a;` 定义的是指针常量。指针常量可以通过`*var = 10`进行修改，与引用的作用一样。

**常指针常量**：`const int* const var = &a;` 定义的是常指针常量。常指针常量既不可通过解引用进行值的修改，也不可更换指向的变量。

## 引用

c++新增类型，`int a = 1;  int& b = a;`定了引用b。引用的数据类型必须相同，不可强转。

整个过程a与a的引用地址始终相同.
```cpp
int a = 1;
int& ra = a;
// a = 1 / ra =1 
// b 
int b = 2;
ra = b;
// a = 2, ra =2
```

引用是伪装的指针常量.传引用会将形参和实参一起进行改变.`int* pt; int*& p = pt;` 指针的引用,可以替换二级指针.数组不存在引用.

`const`修饰时,会创建临时变量让引用指向临时变量,在函数直接时,形参存在引用时会出现该情况,`const`修改指针时不会.

**返回引用**可以减少内存的拷贝,常用于大的数据类型返回值(一般为引用传递的形参),*注意*返回局部变量视为操作野指针.

## 数组

**初始化**：`int arry[3];` []内部数组长度，必须为常数，在linux平台下是可以是使用`int a =10; int b[a];`。数组下标以0开始。`int a[2] = {1, 2}`。`int a[2] = {0}  === int a[2] = {}` 都是 {0, 0}。`int a[2] = {1}`，是{1, 0}。

**遍历方式**：for循环，foreach`for(auto item: arry){}`

**拷贝方式**：不可直接通过`=`进行拷贝，通过`mempy(a, b)` b==>a

**越界**：在不同的平台的表现不同，本质是野指针。

**作为参数传递**：形参`void func(int arr[], int len)`或者`void func(int* arr, int len)`，在函数内部使用`sizeof`是用第一种方式，数组指针。

**二维数组**；在内存中二维数组的空间也是连续的。因此可用过`int a[2][3] = {1, 2, 3, 4, 5, 6}`进行初始化分配。

**行指针(数组指针)**；`int (*a)[3]` 指向在二维数组中行为3的数组。`void fun(int p[][3], int len)`/`void fun(int (*p)[3], int len)`将二维数组作为参数传递的方式。

```cpp
int a[4] = {1,2,3,4};
int* p = a;
&a[1][0] === *(p+0)
```

**动态数组**：在堆上分配内存，`type* p = new tpye[];` 返回也是第一元素的地址。注意需要通过`delet[] p;`释放内存，不可使用~`sizeof`~获取数组长度。

### 数组指针

数组指针是一个指向数组的指针。数组在C++中是连续存储的，所以数组名本身就是一个指针。当你声明一个数组时，数组名就是这个数组首元素的地址，但数组名并不只代表着地址在sizeof时返回的整个数组的长度。 当指向数组为二维数组时，注意指针的嵌套关系

```cpp
int a[2];
// a的值是&a[0]即第一个值的地址，。因此在使用指针操作数组时，不需&
int* p = a; 
p+0; //等价于指向a[0]的指针
p+1; //等价于指向a[1]的指针
*(p+1); //取得a[1]的数组
*p+1; //是a[0] = a[0]+1
```

### 排序

`void qsort(void* base, size_t len, size_t type_size, int(*compare)(const void* p1, const void* p2))`形参的依次作用是，数组第一个值，数组长度，数组元素类型大小，回调函数（决定是顺序还逆序)

```cpp
int compare(const void* p1, const void* p2){
    //当值大于0是交换前后，当小于0是后前互相，等于0时不确定。
    return (*(int*)p1)-(*(int*)p2) // 顺序
    // return (*(int*)p2)-(*(int*)p1) // 逆序
}
```
<!-- [内存管理](/note/c++/内存管理.md) -->

## c风格的字符串

c++的`string`类封装了c风格的字符串。`string`会自动拓展内存空间。

`char s = "abc"`和``char s[] = "abc"` 前者为字符，后者为字符串，其**末尾是存在`\0`**。因为c语言中字符串以空字符结尾，所以在申请内存时需要多预留以为的内存空间空间。

**定义与初始化**：`char s[21];` 定义了存放20个字符的字符串。初始化`char s[21] = {0}`，定义字符串需要初始化否则会存在危险，存放垃圾值。

**清空字符串**：1、使用`menset(name, 0, sizeof(name))`将整个字符串清空为`\0`。2、`name[0] = 0;`将字符串的第一元素设置为`\0`，但后面的元素会随机化（成为垃圾值）。

**拷贝**：`strcopy(a, b)`和`strncopy(a, b, n)`，后者拷贝b的n个字符，不会追加空字符。

**拼接**；c++可以通过`+`或`strcat` `strncat`

## 内存管理

### 内存空间

内存空间包含：内核空间、栈、堆、数据段、代码段。地址从高到低。如下图：

![men](/note/c++/men.png)

**内核空间**是操作系统内核所占用的空间，这部分空间是受保护的，不能被用户直接访问。

**栈**是函数调用时使用的空间，每个函数调用都会创建一个栈帧，用于存储函数的**局部变量**、**函数参数**和**函数返回值**。栈空间是自动分配和释放的，栈空间的大小是固定的，可以通过设置栈的大小来控制函数调用的深度。

**堆**是用于动态分配内存的空间，程序可以通过调用malloc、new等函数来在堆上分配内存。堆空间的大小是不固定的，可以通过设置堆的大小来控制内存的使用。

**数据段**是用于存储程序中定义的**静态变量**、**全局变量**等。数据段的空间是固定的，程序运行时会分配相应的空间。

**代码段**是用于存储程序的代码。代码段的空间是固定的，程序运行时会分配相应的空间。

### 栈与堆的区别

1、管理方式不同，栈会自动释放空间，而堆需要手动释放空间。

2、空间大小不同，堆的受限于物理内存空间，栈会更小一点。

3、分配方式不同，栈是静态分配，而堆是动态分配。

4、分配效率不同，栈由操作系统支持，效率会更高。

5、堆由于频繁分配和释放，会导致内存空间不连续，容易产生内存碎片，会导致性能下降。栈是按照进出栈的顺序存放的，因此不会产生碎片。

6、栈向下增长，堆向上增长。

### 堆区内存使用

1、申请内存。`int* p = new int(5);` c++通过new关键字动态分配内存，在面向对象编程时常用。在c中可以通过`malloc`函数动态分配内存。`int* p = new (std::nothorw)int[5];`这样在申请的堆内存不足会返回空指针`nullpt`。

2、使用内存。`*p = 8;` 内存的操作和使用只能通过指针实行。 

3、释放内存。c++通过`delet p;`。c通过free关键字释放内存。如果不释放会导致内存泄漏。不可重复释放同一内存，视为操作野指针。

**内存泄漏**是指程序中不再使用的内存没有及时释放，导致内存占用越来越多，最终导致内存溢出。

**内存溢出**是指程序中使用的内存超过了系统分配的内存，导致程序无法继续运行。

*注意*：动态内存不与变量绑定。因此，动态内存的生命周期和整个程序相同，即使操作该内存的指针在某作用域失效申请的动态内存依然存在。当程序结束时，系统将自动回未释放的内存。

## 结构体

```cpp
struct name{int a, char b, int c}; // 正式命名
typedef struct name{} n; // 别名

struct name a; // c必须struct，可以使用第二种方式定义
name b; // c++不需要
```

结构体名是标识符。C++中不提倡使用类作为成员和函数作为成员。

初始化值的方式`name a = {0}`或`name a{0}` `name a = {1, 2, 3}`，初始化可以在定义时在结尾追加。

**内存占用大小**；结构体是会内存对齐，`pragam park(字节数)`修改对齐的规则，取决于编译器。

### 结构体指针

```cpp
name a = {0};
name* p = &a;

// 访问成员方式
(*p).a;
p->a;
```

*结构体变量名和数组不同，并没有解析为地址*

**可以通过new关键字进行动态分配内存**

### 结构体中的指针

当结构体中成员变量含有指针时，`sizeof`和`menset`函数的使用，后者可能会导致内存泄漏`menset`一般用于清空会将指针的地址变为空指针。需要单独对带指针的成员进行清空。`string`结构体中就存在一个这样的成员，因此当结构体中存在`string`类型时需要注意。

## 共同体

又称为联合体、共用体。`union`关键字。共同体占用内存大小是**成员类型中内存占用最大**的大小，存在内存对齐。所有成员使用同一块内存。共同体的值为最后一个进行赋值操作成员的值。linux支持匿名共同体。

## 枚举

创建常量的一种方式

```cpp
enum colors {red, bule, green=0, other};  // 0001

colors a = red; // 只能在以上四种选择一个
```

## 函数