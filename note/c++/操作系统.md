## 操作系统 

OS是管理软件的一种软件

C程序与可以看成是一种状态机。因为每一步程序的执行都会是状态的变化，其中状态包括函数的栈帧、变量的值、PC等。

状态机是一个状态的集合，状态之间通过转移，来完成一个任务的过程。通俗的理解：A -> B -> C 就是一个简单的状态机。

系统调用（syscall）：系统处理状态转换的一种方式（本质也是一种状态机）。在不同平台实现的方式对应的不同汇编指令不同，存储系统调用参数的寄存器也不同，这是不同架构间的区别。

多发射，乱序执行，按序提交（处理器能看到即将进行的步骤，并且优化）。因此，多处理器丢失即时可见性。（宽松内存模型）。 

python的生成器可以看作线程or一个局部的状态机。
## 并发

线程和进程是并发的基础。线程是CPU的调度基本单位，进程是资源调度的基本单位。在实现上并没有太大的区别，但进程拥有独立的地址空间，线程也有独立的地址空间，多个线程可以共享同一进程的内存空间。

### peterson算法

一种互斥的约定算法，保证了原子性。store(设置标志表明要去竞争资源)和load(获取当前是否有人在使用资源，当没有人使用时由速度决定，因此是随机的)

```C
void TA(){
    while(1){
        x = 1;
        turn = B;   // sotre
        while(y && turn == B); // load
        use();  // 进入临界区
        x = 0;
    }
}
void TB(){
    while(1){
        y = 1;
        turn = A;
        while(x && turn == A);
        use();
        y = 0;
    }
}
```
### 互斥
#### 自旋锁

通过原子指令，去交换锁。
这是c++实现的一个自旋锁
```cpp
#include <atomic>
 
#define LOCK 1
#define UNLOCK 0
 
// 假设XCHG是一个原子交换函数，这里我们使用std::atomic_exchange来模拟
// 亦可以使用汇编代码模拟
template<typename T>
T XCHG(std::atomic<T>* ptr, T newval) {
    return std::atomic_exchange(ptr, newval);
}
 
std::atomic<int> status(UNLOCK); // 使用std::atomic确保原子性
 
void lock() {
    // 如果置换出的状态时锁可以拿的
    while (XCHG(&status, LOCK) == LOCK) {
        // 自旋等待，直到获取锁
    }
    // 注意：这里不需要再次交换status，因为我们已经成功获取了锁
}
 
void unlock() {
    XCHG(&status, LOCK); // 释放锁
}
```
适合：操作系统内核的并发数据结构（短临界区）
问题： 1、不同CPU的缓存同步。2、空转导致其他CPU在干没有意义的工作。3、拥有锁的线程可能被sleep。

#### 互斥锁

通过系统调用，实现原子的store和load去获取锁。

适合：长临界区
问题：系统调用进入内核，导致过多额外的开销时间

#### futex

### 同步