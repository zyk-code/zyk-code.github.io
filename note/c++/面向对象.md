# 面向对象

### 类

#### 成员类型

公有（public）、私有(private)、保护(protect)，可以是数据，亦可以是函数

#### 友元函数

`friend` 关键字，允许类外部成员访问成员

例如：

```cpp

    friendcomplex&__doapl (complex*, constcomplex&);

```

可以直接访问传入类的私有属性，比通过函数取会高效。同一个类的各个实例其实是互为友元的。

##### 拷贝赋值

拷贝赋值：本质是一种运算符重载（=），然而因为指针的存在变得特殊。需要将本身存有的数据（指针）清理掉，在进行赋值。（检测自我赋值）。

#### 构造函数

例子：

```cpp

    complex(double r=0, double i=0):

     :re(r), im(i){}

```

###### 拷贝构造（复制构造）

例如：

```cpp

    // 深拷贝

    complex(const complex& c):

    // 浅拷贝

    complex(complex& c):

```

拷贝构造：编译器有默认的拷贝构造（按位赋值），然而带指针的类，比较特殊，需要我们动态分配内存，避免浅拷贝。在拷贝构造过程中需要进行有效的操作。

##### 移动构造 c++11

```cpp

    complex(complex&& c):

```

#### 析构函数

对象消亡的时候调用，通常在带有指针的对象需要重构，将分配的内存回收（delect）。

#### 堆stack、栈heap

stack 存放某一个作用域的内的内存空间。调用函数、类，就会形成一个栈。

heap 操作系统提供的全局的内存空间。通过new关键字动态获取，注意使用时候需要释放delete。

#### object 的生命周期

stack object 是会在作用域（scope）结束前调用清理（析构），所以也称auto。

static local object 是在离开当前作用域对象依然存在，会在程序结束时清理（析构）。

global object 是在main函数前就存在（构造），析构是在main函数执行后结束（析构）。

#### new 和 delete

new 是先分配内存空间（malloc），在调用构造函数。

1、重构new关键字，内部通过malloc和内存分配内存空间

2、转型

3、构造

delete 是先调用析构函数，在清理内存。

1、调用析构

2、重构delete，内部通过free清理内存空间。

array new 配 array delet。如果不搭，会导致只调用一次析构，从而内存泄漏。

实例：

```cpp

classob:{}

ob* q =newob[3];

    delete[] q;

```

#### static 静态

1、静态成员。修饰成员变量。可以通过 `类名：：`访问。

2、静态函数。static关键字修饰的成员函数。静态函数，只能访问静态成员。同样通过 `类名：：`调用。

### 类与类之间的关系

#### 复合与委托

复合：类内部属性的类型是其他的类。构造的过程是从内向外，是类内的其他类型先构造。析构的过程是从外向内，是类先析构

委托：就是在类内部有一个指针指向被委托的类，借用指针调用需要的方法。和复合不同的是，在构造的时候并不是同时构造的。

#### 继承

无论在哪种继承方式下，子类都**无法访问**父类中访问权限为 private 的成员，友元成员不会被继承。

##### 继承方式

公有（public）：在父类中，访问权限为 public、protected 的属性，继承到子类后，**访问权限不变。**

保护（protect）：在父类中，访问权限为 public、protected 的属性，继承到子类后，**访问权限均为protected**，不能被派生类的对象直接访问，但是可以在派生类的内部和派生类的子类中进行访问。

私有（private）：在父类中，访问权限为 public、protected 的属性，继承到子类后，**访问权限均为private。**

##### 子类的构造与析构

构造的过程：子类调用父类的构造，在进行子类的构造

析构的过程：子类先调用析构，在析构父类。一般的父类的析构函数是一个虚函数。

##### 覆盖

这是处理父类与子类的同名成员的方式。

数据同名：在类内部，子类覆盖父类。在类外部，根据类名作用域区分（::）。

函数同名：子类覆盖父类，这没重载的关系。根据类名作用域区分（::）。

##### 多继承和多层继承

多继承是同时拥有多个父类。在此有虚继承解决多继承访问不明确的问题，但是内存开销大。a->b,c b,c->d

多层继承是a->b->c，这种每层只有一个父类，但存在父类的父类的形式。

#### 多态

多态是泛型编程的一种思想，即同样的代码实现不同的功能。父类的指针具有多种执行状态，所以这是一种运行时的产生的。

多态的实现是可以通过虚函数， `vitual`关键字。

##### 虚函数的种类

非虚函数：子类不需要重写该函数。

虚函数：子类可以重写该函数。

纯虚函数： 子类必须重写该函数。

实例：

```cpp

classob{

    public:

        virtualvoidname() const=0; // 纯虚函数

        virtualvoidname();     // 虚函数

        voidname();

}

classobs: publicob{

    public:

        voidname() // 子类重写

}

```

##### 抽象类与接口类

抽象类：包含有虚函数的类。

接口类：成员函数都是纯虚函数的类。

##### 虚表

虚表是一个指针数组，存放虚函数的函数指针。

存在虚函数的类或继承的类都会存有虚表，类的实例化对象会有虚表指针指向这个列表。

虚表的作用和虚表指针的示意图，多重继承的方式 a->b->c。

![alt text](/note/c++/vptable.png)

注意：在多继承时，该类的实例对象有多个虚表指针。

##### 协变

协变（covariant）是指派生类（子类）中的返回类型可以是基类（父类）中返回类型的子类型。是一种语法特性。

```cpp

classob{

    public:

        virtualob*name(intold, char*name){

            return newob(*this);

        }; // 虚函数

}

classobs: publicob{

    public:

        obs*name(intold, char*name){

            return newobs(*this);

        } // 子类重写

}

```

#### 联编

动态联编：即虚函数的方式。在指在运行时根据对象的类型确定方法调用的具体实现。

静态联编：指在编译阶段就将函数实现和函数调用关联起来。例如：函数重写、模板、类型强转。
