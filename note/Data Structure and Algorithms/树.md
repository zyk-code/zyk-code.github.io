
## 二叉树遍历
**层序遍历** 
```cpp
class Solution {
public:
    
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> ans;
        if(!root) return ans;

        queue<TreeNode*> q;
        q.push(root);

        while(!q.empty()){
            // 当前层的节点个数
            int len = q.size();
            ans.emplace_back(vector<int> ());
            // 遍历当前层的节点
            for(int i=1; i<=len; i++){
                TreeNode* node = q.front();
                q.pop();
                ans.back().emplace_back(node->val);
                // 添加下一层的节点
                if(node->left) q.push(node->left);
                if(node->right) q.push(node->right);
            }
                
        }
        return ans;
    }
};
```

### 先序遍历
递归实现
```cpp
class Solution {
public:
    vector<int> preinorderTraversal(TreeNode* root) {
        vector<int> ans;
        inorder(root, ans);
        return ans;
    }   
    void inorder(TreeNode* root, vector<int>& res){
        if(!root){
            return;
        }
        // 节点 左 右
        res.push_back(root->val);
        inorder(root->left, res);
        inorder(root->right, res);
    }
};
```
**非递归：利用栈实现，注意入栈的顺序（先右子树入栈，这样确保栈顶是左子树）。**
```cpp
class Solution {
public:
    vector<int> preinorderTraversal(TreeNode* root) {
        vector<int> ans;
        stack<TreeNode*> sk;
        TreeNode* current = root;

        if(current == nullptr) return ans;

        while(!sk.empty() || current != nullptr){
            current = sk.top();
            sk.pop();
            ans.push_back(current->val);
            if(current->right) sk.push(current->right);
            if(current->left) sk.push(current->left);
        }
        return ans;
    }
};


### 中序遍历
递归实现
```cpp
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> ans;
        inorder(root, ans);
        return ans;
    }   
    void inorder(TreeNode* root, vector<int>& res){
        if(!root){
            return;
        }
        // 左 节点 右
        inorder(root->left, res);
        res.push_back(root->val);
        inorder(root->right, res);
    }
};
```
**非递归：利用栈进行存储节点**
```cpp
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> ans;
        TreeNode* current = root;
        stack<TreeNode*> sk;

        while(!sk.empty() || current != nullptr){
            // 当前节点非空，入栈且转向左子树
            while(current != nullptr){
                sk.push(current);
                current = current->left;
            }
            if(!sk.empty()){
                // 取出栈顶节点，最左侧节点
                current = sk.top();
                sk.pop();
                ans.push_back(current->val);
                // 转向其他右边子树
                current = current->right;
            }
        }
        return ans;
    }   
};
```
## AVL树

## B树

## B+树

## 红黑树

